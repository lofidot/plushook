<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pomodoro Timer</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background-color: #f5f5f5;
    }
    
    .timer-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      background-color: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    .timer-type-switcher {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      justify-content: center;
    }
    
    .timer-type-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background-color: #ddd;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .timer-type-dot.active {
      background-color: #000;
      transform: scale(1.2);
    }
    
    .timer-type-tooltip {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background-color: #333;
      color: white;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.2s ease;
      pointer-events: none;
      margin-bottom: 8px;
    }
    
    .timer-type-dot-container {
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .timer-type-dot-container:hover .timer-type-tooltip {
      opacity: 1;
    }
    
    .mode-switcher {
      display: flex;
      gap: 24px;
      margin-bottom: 24px;
      margin-top: 8px;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .mode-switcher.hidden {
      max-height: 0;
      margin: 0;
      padding: 0;
      opacity: 0;
      pointer-events: none;
      overflow: hidden;
    }
    
    .mode-btn {
      padding: 0;
      border: none;
      font-size: 16px;
      cursor: pointer;
      background: none;
      transition: all 0.2s ease;
      color: #999;
      font-weight: normal;
      position: relative;
    }
    
    .mode-btn.active {
      color: #333;
      font-weight: 500;
    }
    
    .mode-btn.active::after {
      content: '';
      position: absolute;
      bottom: -4px;
      left: 0;
      right: 0;
      height: 1px;
      background-color: #333;
    }
    
    .mode-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .timer-display {
      margin-bottom: 8px;
      width: 100%;
      text-align: center;
      position: relative;
    }
    
    .time {
      font-size: 5rem;
      font-weight: bold;
      cursor: text;
      position: relative;
    }
    
    .timer-display:not(.disabled):hover .edit-hint {
      opacity: 1;
      transform: translateY(0);
    }
    
    .edit-hint {
      position: absolute;
      bottom: -20px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      color: #777;
      opacity: 0;
      transform: translateY(-5px);
      transition: all 0.2s ease;
      pointer-events: none;
    }
    
    .timer-display.disabled .time {
      cursor: default;
    }
    
    /* Goal Section */
    .goal-section {
      width: 100%;
      margin-top: 16px;
      margin-bottom: 8px;
      transition: all 0.3s ease;
    }
    
    .goal-section.hidden {
      max-height: 0;
      margin: 0;
      padding: 0;
      opacity: 0;
      pointer-events: none;
      overflow: hidden;
    }
    
    .goal-divider {
      width: 100%;
      height: 0.5px;
      background-color: #ddd;
    }
    
    .goal-input {
      width: 100%;
      padding: 8px 0;
      border: none;
      border-bottom: 1px solid #ddd;
      font-size: 16px;
      font-family: inherit;
      background: transparent;
      text-align: center;
      transition: border-color 0.2s ease;
      color: #666;
    }
    
    .goal-input:focus {
      outline: none;
      border-bottom-color: #333;
      color: #333;
    }
    
    .goal-input::placeholder {
      color: #999;
      font-style: normal;
    }
    
    .time-input {
      font-size: 5rem;
      font-weight: bold;
      width: 100%;
      text-align: center;
      border: none;
      outline: none;
      background: none;
    }
    
    .progress-bar {
      width: 100%;
      height: 12px;
      background-color: #eee;
      border-radius: 999px;
      margin-bottom: 24px;
      margin-top: 16px;
      overflow: hidden;
    }
    
    .progress {
      height: 100%;
      background-color: #000;
      border-radius: 999px;
      width: 0%;
      transition: width 1s linear;
    }
    
    .controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 16px;
      width: 100%;
    }
    
    .control-buttons {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
    }
    
    .adjust-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: none;
      background-color: #eee;
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
    }
    
    .adjust-btn:hover {
      background-color: #ddd;
    }
    
    .adjust-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .start-btn {
      padding: 12px 24px;
      min-width: 100px;
      border-radius: 999px;
      border: none;
      background-color: #eee;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-btn:hover {
      background-color: #ddd;
    }
    
    .pause-btn {
      width: 44px;
      height: 44px;
      border: none;
      background-color: #eee;
      color: #333;
      cursor: pointer;
      transition: all 0.2s ease;
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    
    .pause-btn.visible {
      display: flex;
    }
    
    .pause-btn:hover {
      background-color: #ddd;
    }
    
    .restart-btn {
      width: 44px;
      height: 44px;
      border: none;
      background-color: #eee;
      color: #333;
      cursor: pointer;
      transition: all 0.2s ease;
      display: none;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }
    
    .restart-btn.visible {
      display: flex;
    }
    
    .restart-btn:hover {
      background-color: #ddd;
    }
    
    /* Cycle dots */
    .cycles-container {
      margin-top: 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
    }
    
    .cycles-container.hidden {
      display: none;
    }
    
    .cycle-dot {
      width: 16px;
      height: 16px;
      border: 2px solid #ddd;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      background-color: white;
    }
    
    .cycle-dot.half-filled::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 50%;
      height: 100%;
      background-color: #666;
    }
    
    .cycle-dot.full-filled {
      background-color: #333;
      border-color: #333;
    }
    
    /* Settings Modal */
    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    
    .settings-modal.open {
      display: flex;
    }
    
    .settings-content {
      background-color: white;
      padding: 32px;
      border-radius: 12px;
      width: 90%;
      max-width: 400px;
      max-height: 90vh;
      position: relative;
      overflow-y: auto;
      /* Hide scrollbar but keep functionality */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE and Edge */
    }
    
    .settings-content::-webkit-scrollbar {
      display: none; /* Chrome, Safari, Opera */
    }
    
    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }
    
    .settings-title {
      font-size: 20px;
      font-weight: 600;
    }
    
    .close-btn {
      width: 32px;
      height: 32px;
      border: none;
      background: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      transition: color 0.2s ease;
    }
    
    .close-btn:hover {
      color: #333;
    }
    
    .settings-group {
      margin-bottom: 20px;
    }
    
    .settings-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #333;
    }
    
    .settings-input {
      width: 100%;
      padding: 12px;
      border: 2px solid #eee;
      border-radius: 8px;
      font-size: 16px;
      transition: border-color 0.2s ease;
    }
    
    .settings-input:focus {
      outline: none;
      border-color: #333;
    }
    
    /* Compact Grid Layout */
    .settings-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 24px;
    }
    
    .settings-group-compact {
      display: flex;
      flex-direction: column;
    }
    
    .settings-label-compact {
      font-size: 12px;
      font-weight: 500;
      color: #333;
      margin-bottom: 6px;
      text-align: left;
    }
    
    .settings-input-compact {
      width: 100%;
      padding: 8px;
      border: 2px solid #eee;
      border-radius: 6px;
      font-size: 14px;
      text-align: left;
      transition: border-color 0.2s ease;
    }
    
    .settings-input-compact:focus {
      outline: none;
      border-color: #333;
    }
    
    /* Sound Input Container */
    .sound-input-container {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .sound-select {
      flex: 1;
    }
    
    .play-sound-btn {
      width: 44px;
      height: 44px;
      border: none;
      background-color: #eee;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s ease;
      flex-shrink: 0;
    }
    
    .play-sound-btn:hover {
      background-color: #ddd;
    }
    
    .play-sound-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    /* Preset Buttons */
    .preset-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .preset-btn {
      padding: 8px 16px;
      border: 2px solid #eee;
      background: white;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      flex: 1;
      min-width: 100px;
    }
    
    .preset-btn:hover {
      border-color: #ddd;
      background-color: #f9f9f9;
    }
    
    .preset-btn.active {
      border-color: #333;
      background-color: #333;
      color: white;
    }
    
    /* Settings Divider */
    .settings-divider {
      width: 100%;
      height: 1px;
      background-color: #eee;
      margin: 20px 0;
    }
    
    /* Mobile Responsive */
    @media (max-width: 480px) {
      .settings-content {
        width: 95%;
        padding: 24px;
        max-height: 85vh;
      }
      
      .settings-grid {
        gap: 12px;
      }
      
      .settings-input-compact {
        padding: 6px;
        font-size: 13px;
      }
      
      .settings-label-compact {
        font-size: 11px;
      }
      
      .preset-btn {
        padding: 6px 12px;
        font-size: 13px;
        min-width: 80px;
      }
    }
    
    .settings-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }
    
    .settings-btn-secondary {
      padding: 10px 20px;
      border: 2px solid #eee;
      background: white;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .settings-btn-secondary:hover {
      border-color: #ddd;
      background-color: #f9f9f9;
    }
    
    .settings-btn-primary {
      padding: 10px 20px;
      border: none;
      background-color: #333;
      color: white;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }
    
    .settings-btn-primary:hover {
      background-color: #222;
    }
    
    /* Icons */
    .icon {
      width: 20px;
      height: 20px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    
    .icon-small {
      width: 16px;
      height: 16px;
      stroke-width: 2;
      stroke: currentColor;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
  </style>
</head>
<body>
  <div class="timer-container">
    <!-- Timer Type Switcher (dots) -->
    <div class="timer-type-switcher">
      <div class="timer-type-dot-container">
        <div class="timer-type-dot" data-timer-type="endless"></div>
        <div class="timer-type-tooltip">Endless Timer</div>
      </div>
      <div class="timer-type-dot-container">
        <div class="timer-type-dot" data-timer-type="simple"></div>
        <div class="timer-type-tooltip">Simple Timer</div>
      </div>
      <div class="timer-type-dot-container">
        <div class="timer-type-dot active" data-timer-type="pomodoro"></div>
        <div class="timer-type-tooltip">Pomodoro</div>
      </div>
      <div class="timer-type-dot-container">
        <div class="timer-type-dot" data-timer-type="sleep"></div>
        <div class="timer-type-tooltip">Sleep Timer</div>
      </div>
      <div class="timer-type-dot-container">
        <div class="timer-type-dot" data-timer-type="settings"></div>
        <div class="timer-type-tooltip">Settings</div>
      </div>
    </div>
    
    <!-- Mode Switcher (only visible for Pomodoro) -->
    <div class="mode-switcher" id="modeSwitcher">
      <button class="mode-btn active" data-mode="focus">Focus Time</button>
      <button class="mode-btn" data-mode="short-break">Short Break</button>
      <button class="mode-btn" data-mode="long-break">Long Break</button>
    </div>
    
    <!-- Timer Display -->
    <div class="timer-display" id="timerDisplay">
      <div class="time" id="time">25:00</div>
      <div class="edit-hint">Click to edit</div>
    </div>
    
    <!-- Goal Section -->
    <div class="goal-section" id="goalSection">
      <div class="goal-divider"></div>
      <input 
        type="text" 
        class="goal-input" 
        id="goalInput" 
        placeholder="Goal for This Session?"
      />
    </div>
    
    <!-- Progress Bar -->
    <div class="progress-bar">
      <div class="progress" id="progress"></div>
    </div>
    
    <!-- Controls -->
    <div class="controls">
      <button class="adjust-btn" id="decrease">−</button>
      <div class="control-buttons">
        <button class="start-btn" id="startBtn">Start</button>
        <button class="pause-btn" id="pauseBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <line x1="9" y1="6" x2="9" y2="18"></line>
            <line x1="15" y1="6" x2="15" y2="18"></line>
          </svg>
        </button>
        <button class="restart-btn" id="restartBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8"></path>
            <path d="M21 3v5h-5"></path>
          </svg>
        </button>
      </div>
      <button class="adjust-btn" id="increase">+</button>
    </div>
    
    <!-- Pomodoro Cycles -->
    <div class="cycles-container" id="cyclesContainer">
      <!-- Cycle dots will be generated here -->
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="settings-modal" id="settingsModal">
    <div class="settings-content">
      <div class="settings-header">
        <h2 class="settings-title">Settings</h2>
        <button class="close-btn" id="closeSettingsBtn">×</button>
      </div>
      
      <!-- Preset Configurations -->
      <div class="settings-group">
        <label class="settings-label">Timer Presets</label>
        <div class="preset-buttons">
          <button type="button" class="preset-btn" data-preset="classic">25-5-15</button>
          <button type="button" class="preset-btn" data-preset="extended">50-10-30</button>
          <button type="button" class="preset-btn" data-preset="custom">Custom</button>
        </div>
      </div>
      
      <!-- Pomodoro Settings Grid -->
      <div class="settings-grid">
        <div class="settings-group-compact">
          <label class="settings-label-compact" for="focusTimeInput">Focus Timer (min)</label>
          <input type="number" class="settings-input-compact" id="focusTimeInput" min="1" max="120" value="25">
        </div>
        <div class="settings-group-compact">
          <label class="settings-label-compact" for="shortBreakInput">Short Break (min)</label>
          <input type="number" class="settings-input-compact" id="shortBreakInput" min="1" max="30" value="5">
        </div>
        <div class="settings-group-compact">
          <label class="settings-label-compact" for="longBreakInput">Long Break (min)</label>
          <input type="number" class="settings-input-compact" id="longBreakInput" min="1" max="60" value="15">
        </div>
        <div class="settings-group-compact">
          <label class="settings-label-compact" for="cyclesInput">Cycles</label>
          <input type="number" class="settings-input-compact" id="cyclesInput" min="1" max="10" value="4">
        </div>
      </div>
      
      <!-- Divider -->
      <div class="settings-divider"></div>
      
      <!-- Other Timer Settings -->
      <div class="settings-grid">
        <div class="settings-group-compact">
          <label class="settings-label-compact" for="simpleTimerInput">Simple Timer (min)</label>
          <input type="number" class="settings-input-compact" id="simpleTimerInput" min="1" max="480" value="25">
        </div>
        <div class="settings-group-compact">
          <label class="settings-label-compact" for="sleepTimerInput">Sleep Timer (min)</label>
          <input type="number" class="settings-input-compact" id="sleepTimerInput" min="1" max="480" value="30">
        </div>
      </div>
      
      <!-- Divider -->
      <div class="settings-divider"></div>
      
      <div class="settings-group">
        <label class="settings-label" for="toneSelect">Completion Sound</label>
        <div class="sound-input-container">
          <select class="settings-input sound-select" id="toneSelect">
            <option value="">No Sound</option>
            <!-- Tone options will be populated from Supabase -->
          </select>
          <button type="button" class="play-sound-btn" id="playSoundBtn" title="Play Focus Timer Sound">
            <svg class="icon-small" viewBox="0 0 24 24">
              <polygon points="5,3 19,12 5,21"></polygon>
            </svg>
          </button>
        </div>
      </div>
      
      <div class="settings-group">
        <label class="settings-label">
          <input type="checkbox" id="showGoalCheckbox" checked style="margin-right: 8px;">
          Show Goal Section
        </label>
      </div>
      
      <div class="settings-actions">
        <button class="settings-btn-secondary" id="cancelSettingsBtn">Cancel</button>
        <button class="settings-btn-primary" id="saveSettingsBtn">Save</button>
      </div>
    </div>
  </div>

  <script>
    // Supabase configuration
    const SUPABASE_URL = 'https://ojeyqqzpmhapnwwupely.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9qZXlxcXpwbWhhcG53d3VwZWx5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc1NDkwMDYsImV4cCI6MjA2MzEyNTAwNn0.8KrxB1P76kTtdaPxH8fINqCa6oB6xzA_BesvXpxsCF4';
    
    // Supabase client setup
    const supabaseClient = {
      async query(table) {
        try {
          const response = await fetch(`${SUPABASE_URL}/rest/v1/${table}?select=*`, {
            headers: {
              'apikey': SUPABASE_ANON_KEY,
              'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
              'Content-Type': 'application/json'
            }
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          return await response.json();
        } catch (error) {
          console.error('Supabase query error:', error);
          return [];
        }
      }
    };

    document.addEventListener('DOMContentLoaded', () => {
      // DOM Elements
      const timerDisplay = document.getElementById('timerDisplay');
      const timeDisplay = document.getElementById('time');
      const progressBar = document.getElementById('progress');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const restartBtn = document.getElementById('restartBtn');
      const decreaseBtn = document.getElementById('decrease');
      const increaseBtn = document.getElementById('increase');
      const modeButtons = document.querySelectorAll('.mode-btn');
      const modeSwitcher = document.getElementById('modeSwitcher');
      const timerTypeDots = document.querySelectorAll('.timer-type-dot');
      const cyclesContainer = document.getElementById('cyclesContainer');
      const settingsModal = document.getElementById('settingsModal');
      const closeSettingsBtn = document.getElementById('closeSettingsBtn');
      const cancelSettingsBtn = document.getElementById('cancelSettingsBtn');
      const saveSettingsBtn = document.getElementById('saveSettingsBtn');
      const focusTimeInput = document.getElementById('focusTimeInput');
      const shortBreakInput = document.getElementById('shortBreakInput');
      const longBreakInput = document.getElementById('longBreakInput');
      const cyclesInput = document.getElementById('cyclesInput');
      const simpleTimerInput = document.getElementById('simpleTimerInput');
      const sleepTimerInput = document.getElementById('sleepTimerInput');
      const toneSelect = document.getElementById('toneSelect');
      const goalSection = document.getElementById('goalSection');
      const goalInput = document.getElementById('goalInput');
      const showGoalCheckbox = document.getElementById('showGoalCheckbox');
      const playSoundBtn = document.getElementById('playSoundBtn');
      const presetButtons = document.querySelectorAll('.preset-btn');
      
      // Settings
      let settings = {
        focusTime: 25,
        shortBreak: 5,
        longBreak: 15,
        totalCycles: 4,
        simpleTimer: 25,
        sleepTimer: 30,
        selectedToneId: null,
        showGoal: true,
        sessionGoal: '',
        currentPreset: 'classic'
      };
      
      // Preset configurations
      const presets = {
        classic: {
          focusTime: 25,
          shortBreak: 5,
          longBreak: 15,
          totalCycles: 4
        },
        extended: {
          focusTime: 50,
          shortBreak: 10,
          longBreak: 30,
          totalCycles: 4
        }
      };
      
      // Available tones from Supabase
      let availableTones = [];
      let currentTone = null;
      
      // State
      let mode = 'focus';
      let timerType = 'pomodoro';
      let timeLeft = 25 * 60;
      let totalTime = 25 * 60;
      let isRunning = false;
      let isEditing = false;
      let timer = null;
      let elapsedTime = 0;
      let currentCycle = 0;
      let cyclePhase = 'focus'; // 'focus', 'short-break', 'long-break'
      let cycleDots = [];
      
      // Apply preset configuration
      function applyPreset(presetName) {
        if (presets[presetName]) {
          const preset = presets[presetName];
          settings.focusTime = preset.focusTime;
          settings.shortBreak = preset.shortBreak;
          settings.longBreak = preset.longBreak;
          settings.totalCycles = preset.totalCycles;
          settings.currentPreset = presetName;
          
          // Update input values
          focusTimeInput.value = preset.focusTime;
          shortBreakInput.value = preset.shortBreak;
          longBreakInput.value = preset.longBreak;
          cyclesInput.value = preset.totalCycles;
        } else if (presetName === 'custom') {
          settings.currentPreset = 'custom';
        }
        
        updatePresetButtons();
      }
      
      // Update preset button states
      function updatePresetButtons() {
        presetButtons.forEach(btn => {
          if (btn.dataset.preset === settings.currentPreset) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      
      // Detect if current settings match a preset
      function detectCurrentPreset() {
        for (const [presetName, preset] of Object.entries(presets)) {
          if (settings.focusTime === preset.focusTime &&
              settings.shortBreak === preset.shortBreak &&
              settings.longBreak === preset.longBreak &&
              settings.totalCycles === preset.totalCycles) {
            settings.currentPreset = presetName;
            return;
          }
        }
        settings.currentPreset = 'custom';
      }
      
      // Load settings from localStorage
      function loadSettings() {
        const savedSettings = localStorage.getItem('pomodoroSettings');
        if (savedSettings) {
          const parsed = JSON.parse(savedSettings);
          settings = { ...settings, ...parsed };
          
          // Update input values
          focusTimeInput.value = settings.focusTime;
          shortBreakInput.value = settings.shortBreak;
          longBreakInput.value = settings.longBreak;
          cyclesInput.value = settings.totalCycles;
          simpleTimerInput.value = settings.simpleTimer;
          sleepTimerInput.value = settings.sleepTimer;
          
          // Update goal settings
          showGoalCheckbox.checked = settings.showGoal;
          goalInput.value = settings.sessionGoal;
          updateGoalDisplay();
          
          // Detect and update preset
          detectCurrentPreset();
          updatePresetButtons();
        }
      }
      
      // Save settings to localStorage
      function saveSettingsToStorage() {
        localStorage.setItem('pomodoroSettings', JSON.stringify(settings));
      }
      
      // Update goal display visibility
      function updateGoalDisplay() {
        if (settings.showGoal) {
          goalSection.classList.remove('hidden');
        } else {
          goalSection.classList.add('hidden');
        }
      }
      
      // Load tones from Supabase
      async function loadTones() {
        console.log('Loading tones from Supabase...'); // Debug log
        try {
          availableTones = await supabaseClient.query('tone');
          console.log('Tones loaded:', availableTones); // Debug log
          populateToneSelect();
          
          // Set current tone based on saved selection
          if (settings.selectedToneId) {
            currentTone = availableTones.find(tone => tone.id === settings.selectedToneId);
            console.log('Current tone set:', currentTone); // Debug log
          }
        } catch (error) {
          console.error('Failed to load tones:', error);
        }
      }
      
      // Populate tone select dropdown
      function populateToneSelect() {
        console.log('Populating tone select...', { toneSelect, availableTones }); // Debug log
        if (!toneSelect) {
          console.log('Tone select element not found'); // Debug log
          return;
        }
        
        // Clear existing options
        toneSelect.innerHTML = '<option value="">No Sound</option>';
        
        // Add tone options
        availableTones.forEach(tone => {
          const option = document.createElement('option');
          option.value = tone.id;
          option.textContent = tone.name;
          if (tone.id === settings.selectedToneId) {
            option.selected = true;
          }
          toneSelect.appendChild(option);
        });
        
        console.log('Tone select populated with', availableTones.length, 'tones'); // Debug log
      }
      
      // Play sound based on timer type and completion
      async function playCompletionSound(completionType) {
        if (!currentTone) return;
        
        let soundUrl = '';
        
        switch (completionType) {
          case 'focus':
            soundUrl = currentTone.focus_timer_url;
            break;
          case 'short-break':
            soundUrl = currentTone.short_break_url;
            break;
          case 'long-break':
            soundUrl = currentTone.long_break_url;
            break;
          case 'cycle-complete':
            // Play cycle complete sound instead of short break when cycle is completed
            soundUrl = currentTone.cycle_complete_url || currentTone.short_break_url;
            break;
          case 'countdown':
            soundUrl = currentTone.countdown_timer_url;
            break;
          case 'sleep':
            soundUrl = currentTone.sleep_timer_url;
            break;
        }
        
        if (soundUrl) {
          try {
            const audio = new Audio(soundUrl);
            audio.volume = 0.7;
            await audio.play();
          } catch (error) {
            console.error('Failed to play sound:', error);
          }
        }
      }
      
      // Play focus timer sound preview
      async function playFocusSound() {
        if (!toneSelect || !availableTones.length) return;
        
        const selectedToneId = toneSelect.value;
        if (!selectedToneId) return;
        
        const selectedTone = availableTones.find(tone => tone.id === selectedToneId);
        if (!selectedTone || !selectedTone.focus_timer_url) return;
        
        try {
          if (playSoundBtn) playSoundBtn.disabled = true;
          const audio = new Audio(selectedTone.focus_timer_url);
          audio.volume = 0.7;
          await audio.play();
        } catch (error) {
          console.error('Failed to play focus sound:', error);
        } finally {
          if (playSoundBtn) playSoundBtn.disabled = false;
        }
      }
      
      // Create cycle dots
      function createCycleDots() {
        cyclesContainer.innerHTML = '';
        cycleDots = [];
        
        for (let i = 0; i < settings.totalCycles; i++) {
          const dot = document.createElement('div');
          dot.className = 'cycle-dot';
          cyclesContainer.appendChild(dot);
          cycleDots.push(dot);
        }
        
        updateCycleDots();
      }
      
      // Update cycle dots display
      function updateCycleDots() {
        cycleDots.forEach((dot, index) => {
          dot.className = 'cycle-dot';
          
          if (index < Math.floor(currentCycle)) {
            dot.classList.add('full-filled');
          } else if (index === Math.floor(currentCycle) && cyclePhase === 'short-break') {
            dot.classList.add('half-filled');
          }
        });
      }
      
      // Get current time based on mode and settings
      function getCurrentTime() {
        switch (mode) {
          case 'focus':
            return settings.focusTime * 60;
          case 'short-break':
            return settings.shortBreak * 60;
          case 'long-break':
            return settings.longBreak * 60;
          default:
            return settings.focusTime * 60;
        }
      }
      
      // Set time based on current mode
      function setTimeForMode() {
        const newTime = getCurrentTime();
        timeLeft = newTime;
        totalTime = newTime;
      }
      function formatTime(seconds) {
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = seconds % 60;
        
        if (hours > 0) {
          return `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        } else {
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
      }
      
      // Parse time string to seconds
      function parseTime(timeString) {
        const parts = timeString.split(':').map(Number);
        
        if (parts.length === 3) {
          // Format: HH:MM:SS
          return parts[0] * 3600 + parts[1] * 60 + parts[2];
        } else if (parts.length === 2) {
          // Format: MM:SS
          return parts[0] * 60 + parts[1];
        } else if (parts.length === 1) {
          // Format: minutes only
          return parts[0] * 60;
        }
        
        return 0;
      }
      
      // Update display
      function updateDisplay() {
        if (timerType === 'endless') {
          timeDisplay.textContent = formatTime(elapsedTime);
          progressBar.style.width = '0%';
          cyclesContainer.classList.add('hidden');
        } else {
          timeDisplay.textContent = formatTime(timeLeft);
          const progressPercent = ((totalTime - timeLeft) / totalTime) * 100;
          progressBar.style.width = `${progressPercent}%`;
          
          if (timerType === 'pomodoro') {
            cyclesContainer.classList.remove('hidden');
            updateCycleDots();
          } else {
            cyclesContainer.classList.add('hidden');
          }
        }
        
        // Toggle button visibility
        if (isRunning) {
          startBtn.style.display = 'none';
          pauseBtn.classList.add('visible');
          restartBtn.classList.add('visible');
        } else {
          startBtn.style.display = 'flex';
          pauseBtn.classList.remove('visible');
          restartBtn.classList.remove('visible');
        }
      }
      
      // Toggle timer
      function toggleTimer() {
        if (isRunning) {
          clearInterval(timer);
          isRunning = false;
          enableControls();
        } else {
          if (timerType !== 'endless' && timeLeft <= 0) resetTimer();
          
          timer = setInterval(() => {
            if (timerType === 'endless') {
              elapsedTime++;
              updateDisplay();
            } else {
              timeLeft--;
              updateDisplay();
              
                              if (timeLeft <= 0) {
                clearInterval(timer);
                isRunning = false;
                
                if (timerType === 'pomodoro') {
                  handlePomodoroComplete();
                } else {
                  // Play countdown completion sound for simple timer
                  playCompletionSound('countdown');
                  enableControls();
                }
              }
            }
          }, 1000);
          
          isRunning = true;
          disableControls();
        }
        
        updateDisplay();
      }
      
      // Handle Pomodoro cycle completion
      async function handlePomodoroComplete() {
        if (cyclePhase === 'focus') {
          // Focus completed
          await playCompletionSound('focus');
          
          cyclePhase = 'short-break';
          toggleMode('short-break');
          toggleTimer(); // Auto-start short break
        } else if (cyclePhase === 'short-break') {
          // Short break completed - increment cycle count
          currentCycle++;
          
          // Check if this completes a full cycle (focus + short break)
          if (currentCycle >= settings.totalCycles) {
            // All cycles completed - play cycle complete sound and start long break
            await playCompletionSound('cycle-complete');
            
            cyclePhase = 'long-break';
            toggleMode('long-break');
            toggleTimer(); // Auto-start long break
          } else {
            // More cycles to go - play regular short break sound and continue
            await playCompletionSound('short-break');
            
            cyclePhase = 'focus';
            toggleMode('focus');
            toggleTimer(); // Auto-start next focus
          }
        } else if (cyclePhase === 'long-break') {
          // Long break completed
          await playCompletionSound('long-break');
          
          currentCycle = 0;
          cyclePhase = 'focus';
          toggleMode('focus');
          enableControls();
        }
        
        updateCycleDots();
      }
      
      // Reset timer
      function resetTimer() {
        clearInterval(timer);
        isRunning = false;
        
        if (timerType === 'endless') {
          elapsedTime = 0;
        } else if (timerType === 'pomodoro') {
          currentCycle = 0;
          cyclePhase = 'focus';
          mode = 'focus';
          setTimeForMode();
        } else if (timerType === 'simple') {
          timeLeft = settings.simpleTimer * 60;
          totalTime = settings.simpleTimer * 60;
        }
        
        updateDisplay();
        enableControls();
        
        // Update mode buttons
        modeButtons.forEach(btn => {
          if (btn.dataset.mode === mode) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      
      // Toggle mode (only for pomodoro)
      function toggleMode(newMode) {
        if (newMode === mode || timerType !== 'pomodoro') return;
        
        mode = newMode;
        clearInterval(timer);
        isRunning = false;
        
        setTimeForMode();
        updateDisplay();
        enableControls();
        
        // Update active button
        modeButtons.forEach(btn => {
          if (btn.dataset.mode === mode) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
      }
      
      // Change timer type
      function changeTimerType(newType) {
        if (newType === timerType) return;
        
        // Handle settings dot click
        if (newType === 'settings') {
          openSettings();
          return;
        }
        
        timerType = newType;
        clearInterval(timer);
        isRunning = false;
        
        // Reset cycles when changing timer type
        currentCycle = 0;
        cyclePhase = 'focus';
        
        // Update timer settings based on type
        if (timerType === 'pomodoro') {
          modeSwitcher.classList.remove('hidden');
          mode = 'focus';
          setTimeForMode();
          createCycleDots();
        } else if (timerType === 'simple') {
          modeSwitcher.classList.add('hidden');
          timeLeft = settings.simpleTimer * 60;
          totalTime = settings.simpleTimer * 60;
        } else if (timerType === 'sleep') {
          modeSwitcher.classList.add('hidden');
          timeLeft = settings.sleepTimer * 60;
          totalTime = settings.sleepTimer * 60;
        } else if (timerType === 'endless') {
          modeSwitcher.classList.add('hidden');
          elapsedTime = 0;
        }
        
        // Update active dot
        timerTypeDots.forEach(dot => {
          if (dot.dataset.timerType === timerType) {
            dot.classList.add('active');
          } else {
            dot.classList.remove('active');
          }
        });
        
        // Update mode buttons
        modeButtons.forEach(btn => {
          if (btn.dataset.mode === 'focus') {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        updateDisplay();
        enableControls();
      }
      
      // Adjust time
      function adjustTime(amount) {
        if (isRunning || timerType === 'endless') return;
        
        timeLeft = Math.max(0, timeLeft + amount);
        totalTime = timeLeft;
        
        // Update settings if in pomodoro mode or sleep mode
        if (timerType === 'pomodoro') {
          const minutes = Math.round(timeLeft / 60);
          if (mode === 'focus') {
            settings.focusTime = minutes;
            focusTimeInput.value = minutes;
          } else if (mode === 'short-break') {
            settings.shortBreak = minutes;
            shortBreakInput.value = minutes;
          } else if (mode === 'long-break') {
            settings.longBreak = minutes;
            longBreakInput.value = minutes;
          }
        } else if (timerType === 'simple') {
          const minutes = Math.round(timeLeft / 60);
          settings.simpleTimer = minutes;
          simpleTimerInput.value = minutes;
        } else if (timerType === 'sleep') {
          const minutes = Math.round(timeLeft / 60);
          settings.sleepTimer = minutes;
          sleepTimerInput.value = minutes;
        }
        
        updateDisplay();
      }
      
      // Handle time display click for editing
      function handleTimeClick() {
        if (isRunning || isEditing || timerType === 'endless') return;
        
        isEditing = true;
        
        // Replace display with input
        const currentTimeText = timeDisplay.textContent;
        timeDisplay.innerHTML = `<input type="text" class="time-input" value="${currentTimeText}" maxlength="8">`;
        
        const timeInput = document.querySelector('.time-input');
        timeInput.focus();
        timeInput.select();
        
        // Handle input blur
        timeInput.addEventListener('blur', finishEditing);
        
        // Handle enter key
        timeInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            finishEditing();
          }
        });
        
        // Handle input
        timeInput.addEventListener('input', (e) => {
          // Allow only numbers and colon
          e.target.value = e.target.value.replace(/[^0-9:]/g, '');
        });
      }
      
      // Finish editing time
      function finishEditing() {
        const timeInput = document.querySelector('.time-input');
        if (!timeInput) return;
        
        let timeValue = timeInput.value;
        
        // Process numeric-only input
        if (!timeValue.includes(':')) {
          // Convert minutes to proper time format
          const minutes = parseInt(timeValue, 10) || 0;
          const hours = Math.floor(minutes / 60);
          const mins = minutes % 60;
          
          if (hours > 0) {
            timeValue = `${hours}:${mins.toString().padStart(2, '0')}:00`;
          } else {
            timeValue = `${mins.toString().padStart(2, '0')}:00`;
          }
        } else if (timeValue.split(':').length === 2) {
          // MM:SS format, keep as is
          const [mins, secs] = timeValue.split(':');
          timeValue = `${mins.padStart(2, '0')}:${secs.padStart(2, '0')}`;
        } else if (timeValue.split(':').length === 3) {
          // HH:MM:SS format, keep as is
          const [hours, mins, secs] = timeValue.split(':');
          timeValue = `${hours}:${mins.padStart(2, '0')}:${secs.padStart(2, '0')}`;
        }
        
        // Parse and update time
        timeLeft = parseTime(timeValue);
        totalTime = timeLeft;
        
        // Update settings if in pomodoro mode or sleep mode
        if (timerType === 'pomodoro') {
          const minutes = Math.round(timeLeft / 60);
          if (mode === 'focus') {
            settings.focusTime = minutes;
            focusTimeInput.value = minutes;
          } else if (mode === 'short-break') {
            settings.shortBreak = minutes;
            shortBreakInput.value = minutes;
          } else if (mode === 'long-break') {
            settings.longBreak = minutes;
            longBreakInput.value = minutes;
          }
        } else if (timerType === 'simple') {
          const minutes = Math.round(timeLeft / 60);
          settings.simpleTimer = minutes;
          simpleTimerInput.value = minutes;
        } else if (timerType === 'sleep') {
          const minutes = Math.round(timeLeft / 60);
          settings.sleepTimer = minutes;
          sleepTimerInput.value = minutes;
        }
        
        // Restore display
        timeDisplay.innerHTML = '';
        timeDisplay.textContent = formatTime(timeLeft);
        isEditing = false;
      }
      
      // Settings functions
      function openSettings() {
        // Update input values with current settings
        focusTimeInput.value = settings.focusTime;
        shortBreakInput.value = settings.shortBreak;
        longBreakInput.value = settings.longBreak;
        cyclesInput.value = settings.totalCycles;
        simpleTimerInput.value = settings.simpleTimer;
        sleepTimerInput.value = settings.sleepTimer;
        
        // Update goal settings
        showGoalCheckbox.checked = settings.showGoal;
        
        // Update tone selection
        if (toneSelect) {
          toneSelect.value = settings.selectedToneId || '';
        }
        
        // Detect current preset and update buttons
        detectCurrentPreset();
        updatePresetButtons();
        
        settingsModal.classList.add('open');
      }
      
      function closeSettings() {
        settingsModal.classList.remove('open');
      }
      
      function saveSettings() {
        console.log('Save button clicked'); // Debug log
        
        // Get values from inputs
        const newFocusTime = parseInt(focusTimeInput.value) || 25;
        const newShortBreak = parseInt(shortBreakInput.value) || 5;
        const newLongBreak = parseInt(longBreakInput.value) || 15;
        const newTotalCycles = parseInt(cyclesInput.value) || 4;
        const newSimpleTimer = parseInt(simpleTimerInput.value) || 25;
        const newSleepTimer = parseInt(sleepTimerInput.value) || 30;
        const newSelectedToneId = toneSelect ? toneSelect.value : null;
        const newShowGoal = showGoalCheckbox ? showGoalCheckbox.checked : true;
        const newSessionGoal = goalInput.value;
        
        console.log('New settings:', { newFocusTime, newShortBreak, newLongBreak, newTotalCycles, newSimpleTimer, newSleepTimer, newSelectedToneId, newShowGoal }); // Debug log
        
        // Update settings
        settings.focusTime = newFocusTime;
        settings.shortBreak = newShortBreak;
        settings.longBreak = newLongBreak;
        settings.totalCycles = newTotalCycles;
        settings.simpleTimer = newSimpleTimer;
        settings.sleepTimer = newSleepTimer;
        settings.selectedToneId = newSelectedToneId || null;
        settings.showGoal = newShowGoal;
        settings.sessionGoal = newSessionGoal;
        
        // Update current tone
        if (newSelectedToneId) {
          currentTone = availableTones.find(tone => tone.id === newSelectedToneId);
        } else {
          currentTone = null;
        }
        
        // Save to localStorage
        saveSettingsToStorage();
        
        // Refresh all timers immediately regardless of running state
        if (timerType === 'pomodoro') {
          setTimeForMode();
          createCycleDots();
        } else if (timerType === 'simple') {
          timeLeft = settings.simpleTimer * 60;
          totalTime = settings.simpleTimer * 60;
        } else if (timerType === 'sleep') {
          timeLeft = settings.sleepTimer * 60;
          totalTime = settings.sleepTimer * 60;
        }
        
        // Update display and goal visibility
        updateDisplay();
        updateGoalDisplay();
        
        console.log('Closing modal'); // Debug log
        
        // Close the settings modal
        closeSettings();
        
        console.log('Settings saved and modal closed'); // Debug log
      }
      
      // Disable controls during running state
      function disableControls() {
        decreaseBtn.classList.add('disabled');
        increaseBtn.classList.add('disabled');
        modeButtons.forEach(btn => btn.classList.add('disabled'));
        timerDisplay.classList.add('disabled');
        timerTypeDots.forEach(dot => dot.parentElement.classList.add('disabled'));
      }
      
      // Enable controls when not running
      function enableControls() {
        decreaseBtn.classList.remove('disabled');
        increaseBtn.classList.remove('disabled');
        modeButtons.forEach(btn => btn.classList.remove('disabled'));
        timerDisplay.classList.remove('disabled');
        timerTypeDots.forEach(dot => dot.parentElement.classList.remove('disabled'));
      }
      
      // Event Listeners
      startBtn.addEventListener('click', toggleTimer);
      pauseBtn.addEventListener('click', toggleTimer);
      restartBtn.addEventListener('click', resetTimer);
      decreaseBtn.addEventListener('click', () => adjustTime(-60)); // Decrease by 1 minute
      increaseBtn.addEventListener('click', () => adjustTime(60));  // Increase by 1 minute
      timeDisplay.addEventListener('click', handleTimeClick);
      
      // Settings event listeners
      closeSettingsBtn.addEventListener('click', () => {
        console.log('Close settings button clicked'); // Debug log
        closeSettings();
      });
      cancelSettingsBtn.addEventListener('click', () => {
        console.log('Cancel settings button clicked'); // Debug log
        closeSettings();
      });
      saveSettingsBtn.addEventListener('click', (e) => {
        console.log('Save settings button clicked'); // Debug log
        e.preventDefault();
        e.stopPropagation();
        saveSettings();
      });
      
      // Close settings when clicking outside
      settingsModal.addEventListener('click', (e) => {
        if (e.target === settingsModal) {
          closeSettings();
        }
      });
      
      modeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (!isRunning && timerType === 'pomodoro') {
            toggleMode(btn.dataset.mode);
          }
        });
      });
      
      // Goal input event listeners
      goalInput.addEventListener('input', () => {
        // Save goal to settings
        settings.sessionGoal = goalInput.value;
        saveSettingsToStorage();
      });
      
      goalInput.addEventListener('blur', () => {
        // Save goal to settings
        settings.sessionGoal = goalInput.value;
        saveSettingsToStorage();
      });
      
      timerTypeDots.forEach(dot => {
        dot.addEventListener('click', () => {
          if (!isRunning) {
            changeTimerType(dot.dataset.timerType);
          }
        });
      });
      
      // Play sound button event listener
      if (playSoundBtn) {
        playSoundBtn.addEventListener('click', playFocusSound);
      }
      
      // Preset button event listeners
      presetButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          applyPreset(btn.dataset.preset);
        });
      });
      
      // Input change listeners to switch to custom preset
      const pomodoroInputs = [focusTimeInput, shortBreakInput, longBreakInput, cyclesInput];
      pomodoroInputs.forEach(input => {
        if (input) {
          input.addEventListener('input', () => {
            // Small delay to allow the input value to update
            setTimeout(() => {
              detectCurrentPreset();
              updatePresetButtons();
            }, 10);
          });
        }
      });
      
      // Initialize
      loadSettings();
      loadTones();
      createCycleDots();
      updateGoalDisplay();
      updateDisplay();
      detectCurrentPreset();
      updatePresetButtons();
    });
  </script>
</body>
</html>

